# WolfXL: Surgical Read-Modify-Write Engine for pycalumya

> **Status**: In Progress (Phase 0+1+2 complete)
> **Created**: 2026-02-15
> **Decision**: DEC-014
> **Codename**: WolfXL
> **Goal**: Enable `load_workbook(path, modify=True)` that is significantly faster than openpyxl/umya
> for modifying existing .xlsx files, by patching ZIP entries surgically instead of parsing the
> full workbook DOM.

## Problem

pycalumya's current dual-mode architecture (calamine read + rust_xlsxwriter write) cannot modify
existing files. Users who do `wb = load_workbook("report.xlsx"); ws["A1"] = "Updated"; wb.save()`
have no path — this is one of openpyxl's most common workflows.

Using umya-spreadsheet for this would match openpyxl's speed (both parse the full DOM), defeating
pycalumya's value proposition of Rust-backed speed.

## Approach

Build **WolfXL** (`XlsxPatcher`) — a new Rust backend that treats .xlsx as a ZIP of XML and only
parses/rewrites the entries affected by user changes. Everything else is copied byte-for-byte.

```
User calls:
  wb = load_workbook("report.xlsx", modify=True)
  wb["Sheet1"]["A1"] = "Updated"
  wb["Sheet1"]["B5"].font = Font(bold=True)
  wb.save("report.xlsx")

Under the hood:
  1. On load: open ZIP, parse workbook.xml + rels to learn sheet→file mapping
     (DO NOT parse worksheet XML, styles, or shared strings yet)
  2. On cell read: use calamine-styled (existing fast reader) for values/formats
  3. On cell write: queue change in Python dict (existing _dirty mechanism)
  4. On save:
     a. Parse only the worksheet XMLs that have dirty cells
     b. Parse sharedStrings.xml if new strings were written
     c. Parse styles.xml if new formats were applied
     d. Stream-patch those XMLs with queued changes
     e. Raw-copy all other ZIP entries unchanged
     f. Write new ZIP, atomic rename
```

### Key performance characteristics

| Operation | Full DOM (openpyxl/umya) | WolfXL |
|-----------|--------------------------|--------|
| Open 50MB file | Parse everything (~seconds) | Read ZIP directory only (~ms) |
| Read cells | Already in memory | Calamine (fast, cached) |
| Modify 10 cells | Mutate DOM | Queue in Python dict |
| Save | Serialize entire DOM + recompress all | Patch 1-3 XMLs + raw-copy rest |

The save step is where the big win lives: a 50MB file with charts, images, and 20 sheets will
only decompress + recompress the 1-2 sheets being modified + sharedStrings + styles. Everything
else is a raw byte copy.

## Existing infrastructure (what we can reuse)

### Already in the Rust crate

| Component | Location | Reusable? |
|-----------|----------|-----------|
| ZIP read helpers | `ooxml_util.rs` — `zip_read_to_string`, `zip_read_to_string_opt` | Direct reuse |
| ZIP rewrite pattern | `rust_xlsxwriter_backend.rs:831-927` — `patch_split_panes_xlsx` | Copy/adapt |
| XML stream-patch | `rust_xlsxwriter_backend.rs:951-1079` — `patch_table_xml_ref` | Adapt pattern |
| Workbook/rels parsing | `ooxml_util.rs` — `parse_workbook_sheet_rids`, `parse_relationship_targets` | Direct reuse |
| Style ID extraction | `calamine_styled_backend.rs:1137-1175` — `parse_cell_style_ids_from_sheet_xml` | Adapt |
| Cell read (values+styles) | `calamine_styled_backend.rs` — full CalamineStyledBook | Direct reuse for reads |
| Dependencies | `zip = "2"`, `quick-xml = "0.37"` | Already in Cargo.toml |

### Need to implement

| Component | Complexity | Notes |
|-----------|-----------|-------|
| Shared string parser | Low | Walk `<sst><si><t>` — straightforward |
| Shared string appender | Low | Append `<si>` entries, update count/uniqueCount attrs |
| cellXfs style lookup | Medium | Parse `<cellXfs>`, match or append new `<xf>` |
| Font/fill/border appender | Medium | Append entries to respective collections in styles.xml |
| Worksheet cell patcher | Medium | Stream-parse `<sheetData>`, find/insert/replace `<c>` elements |
| New row insertion | Low-Medium | Insert `<row>` element at correct sorted position |

## Architecture

### Rust module: WolfXL (`xlsx_patcher/`)

```
rust/excelbench_rust/src/
  wolfxl/
    mod.rs              # WolfXL (XlsxPatcher) struct + PyO3 bindings
    shared_strings.rs   # Parse + append shared string table
    styles.rs           # Parse + append cellXfs, fonts, fills, borders
    sheet_patcher.rs    # Stream-edit worksheet XML cells
    zip_rewrite.rs      # Copy-with-patches ZIP rewriter
```

### Core struct

```rust
#[pyclass]
pub struct XlsxPatcher {
    file_path: String,
    // Lazily parsed on first save
    sheet_paths: HashMap<String, String>,        // sheet name → xl/worksheets/sheetN.xml
    // Queued changes (populated from Python)
    cell_values: HashMap<(String, String), CellPatch>,  // (sheet, "A1") → patch
    cell_formats: HashMap<(String, String), FormatPatch>,
}

#[pymethods]
impl XlsxPatcher {
    #[staticmethod]
    fn open(path: &str) -> PyResult<Self>;

    fn queue_value(&mut self, sheet: &str, cell: &str, payload: HashMap<String, PyObject>);
    fn queue_format(&mut self, sheet: &str, cell: &str, format: HashMap<String, PyObject>);
    fn queue_border(&mut self, sheet: &str, cell: &str, border: HashMap<String, PyObject>);

    fn save(&self, path: &str) -> PyResult<()>;
    fn save_in_place(&self) -> PyResult<()>;  // atomic rename
}
```

### Python integration in pycalumya

```python
# _workbook.py
class Workbook:
    def __init__(self):
        self._rust_reader = None      # CalamineStyledBook (read-only mode)
        self._rust_writer = None      # RustXlsxWriterBook (write-only mode)
        self._rust_patcher = None     # XlsxPatcher (modify mode) ← NEW

def load_workbook(filename: str, modify: bool = False) -> Workbook:
    if modify:
        wb = Workbook.__new__(Workbook)
        wb._rust_reader = CalamineStyledBook(filename)   # reads via calamine
        wb._rust_patcher = XlsxPatcher.open(filename)    # patches via patcher
        wb._rust_writer = None
        # ...
    else:
        # existing read-only path
```

Cell flush for modify mode:
```python
def _flush(self):
    patcher = self._workbook._rust_patcher
    if patcher is not None:
        for row, col in self._dirty:
            cell = self._cells[(row, col)]
            coord = rowcol_to_a1(row, col)
            if cell._value_dirty:
                patcher.queue_value(self._title, coord, python_value_to_payload(cell._value))
            if cell._format_dirty:
                patcher.queue_format(self._title, coord, format_dict)
                patcher.queue_border(self._title, coord, border_dict)
```

## OOXML format reference (for implementers)

### Cell element (`<c>`) in worksheet XML

```xml
<row r="3">
  <c r="A3" s="5" t="s">    <!-- s=style index, t=type (s=shared string) -->
    <v>42</v>                 <!-- value: shared string index, or number, or bool -->
  </c>
  <c r="B3" s="0">           <!-- t omitted = number -->
    <v>3.14</v>
  </c>
  <c r="C3" s="2" t="str">   <!-- inline string -->
    <v>hello</v>
  </c>
  <c r="D3" s="1">
    <f>SUM(A1:A2)</f>         <!-- formula -->
    <v>30</v>                 <!-- cached result (clear on formula change) -->
  </c>
</row>
```

Type indicators: `s` = shared string index, `str` = inline string, `b` = boolean,
`e` = error, omitted = number.

### Shared string table (`xl/sharedStrings.xml`)

```xml
<sst count="100" uniqueCount="50">
  <si><t>First string</t></si>          <!-- index 0 -->
  <si><t>Second string</t></si>         <!-- index 1 -->
  <si><r><t>Rich </t></r><r><rPr><b/></rPr><t>text</t></r></si>  <!-- rich text -->
</sst>
```

Appending is safe: add `<si>` elements at end, increment count + uniqueCount.
Existing indices remain stable.

### Style references (`xl/styles.xml`)

```xml
<fonts count="2">
  <font><sz val="11"/><name val="Calibri"/></font>    <!-- fontId=0 -->
  <font><b/><sz val="14"/><name val="Arial"/></font>  <!-- fontId=1 -->
</fonts>
<fills count="2">
  <fill><patternFill patternType="none"/></fill>       <!-- fillId=0 -->
  <fill><patternFill patternType="solid"><fgColor rgb="FFFF0000"/></patternFill></fill>
</fills>
<borders count="1">
  <border>...</border>                                  <!-- borderId=0 -->
</borders>
<cellXfs count="2">
  <xf numFmtId="0" fontId="0" fillId="0" borderId="0"/> <!-- s=0 (default) -->
  <xf numFmtId="0" fontId="1" fillId="1" borderId="0"   <!-- s=1 (bold+red) -->
      applyFont="1" applyFill="1"/>
</cellXfs>
```

Cell `s` attribute → cellXfs index → component IDs (fontId, fillId, borderId, numFmtId).
Appending is safe: add to each collection, increment counts, add new `<xf>`.

## Phases

### Phase 0: Foundation — OOXML parsers in Rust [DONE]

Implemented in `rust/excelbench_rust/src/wolfxl/` submodule:

- [x] **0.1** Shared string table parser: `parse_shared_strings(xml) → Vec<String>`
  - Handles plain `<si><t>` and rich text `<si><r><t>` runs (concatenate)
  - 6 unit tests (plain, rich text, empty, mixed, XML entities, empty entries)
- [x] **0.2** Shared string appender: DEFERRED — using inline strings (`t="str"`) instead
  - Inline strings avoid touching sharedStrings.xml entirely (simpler + faster)
- [x] **0.3** cellXfs parser: `parse_cellxfs(xml) → Vec<XfEntry>`
  - Extracts fontId, fillId, borderId, numFmtId, apply* flags per entry
- [x] **0.4** Style appender: `apply_format_spec(xml, spec) → (new_xml, xf_index)`
  - `inject_into_section()` — append elements to fonts/fills/borders/cellXfs
  - `find_or_create_num_fmt()` — handles built-in + custom number formats
  - `FontSpec`, `FillSpec`, `BorderSpec`, `AlignmentSpec`, `FormatSpec` data types
  - 7 unit tests (inject, num_fmt, format_spec, cellXfs parsing, count_section)
- [x] **0.5** Unit tests for all parsers: 13 total tests across shared_strings + styles

### Phase 1: Worksheet cell patcher + ZIP rewriter [DONE]

- [x] **1.1** Cell finder/replacer: stream-parse `<sheetData>`, locate `<c r="A1">`, replace value/type/style
  - Handles: string (inline `t="str"`), number, boolean, formula, blank
  - Preserves style index from original cell when not explicitly patched
  - Uses `skip_until_cell_end` flag to suppress original cell children during replacement
  - 8 unit tests (replace, insert cell, insert row, formula, style, boolean, empty sheetData, no-op)
- [x] **1.2** Cell inserter: inserts at correct row/col position
  - Inserts new `<row>` elements at correct sorted position
  - Inserts new `<c>` elements within existing rows after row close
  - Handles self-closing `<row/>` and `<sheetData/>` elements
- [x] **1.3** ZIP rewriter: `XlsxPatcher` PyO3 class with `open()` / `save()` / `save_in_place()`
  - Parses workbook.xml + rels for sheet→file mapping
  - `queue_value()` / `queue_format()` / `queue_border()` for queueing changes
  - Raw-copies unchanged ZIP entries, only recompresses modified worksheets
  - Atomic rename for save_in_place
- [x] **1.4** Integration test: load `01_cell_values.xlsx`, patch all value types, verify with openpyxl
  - All 7 cell types verified: string, int, float, boolean, formula, blank, new-cell-insertion (Z99)

### Phase 2: pycalumya integration [DONE]

- [x] **2.1** Create `XlsxPatcher` pyclass — DONE in Phase 1.3
- [x] **2.2** Register in `lib.rs` (wolfxl feature flag) — DONE
- [x] **2.3** Add `modify=True` parameter to `pycalumya.load_workbook()`
  - `_from_patcher()` classmethod creates modify-mode workbook
  - `_rust_reader` = CalamineStyledBook, `_rust_patcher` = XlsxPatcher
  - `save()` dispatches to patcher in modify mode
- [x] **2.4** Update `_worksheet._flush()` to dispatch to patcher when in modify mode
  - `_flush_to_patcher()` calls `queue_value()`/`queue_format()`/`queue_border()`
  - Rust `dict_to_format_spec` accepts both key styles (`h_align`/`horizontal`, `wrap`/`wrap_text`)
- [x] **2.5** Test: 8 modify mode tests (string, number, bool, formula, preserve, RMW, insert, repr)
  - All verified with openpyxl + pycalumya readback

### Phase 3: Format patching [~1-2 sessions]

- [ ] **3.1** Font writes: bold, italic, underline, strikethrough, name, size, color
- [ ] **3.2** Fill writes: solid pattern fill with fg/bg color
- [ ] **3.3** Border writes: thin/medium/thick + color for all 4 sides + diagonal
- [ ] **3.4** Alignment writes: horizontal, vertical, wrap_text, indent, rotation
- [ ] **3.5** Number format writes: custom format codes
- [ ] **3.6** Combined test: modify values + all format properties, verify round-trip

### Phase 4: Edge cases + benchmarks [~1 session]

- [ ] **4.1** Handle missing sharedStrings.xml (some files use inline strings only)
- [ ] **4.2** Handle missing styles.xml (rare but possible)
- [ ] **4.3** Preserve XML declaration, namespaces, and processing instructions
- [ ] **4.4** Test with large files (10MB+): charts, images, macros, VBA — verify preservation
- [ ] **4.5** Benchmark: modify 10 cells in a 50MB file — measure vs openpyxl
- [ ] **4.6** Benchmark: modify 1000 cells in a 5MB file — measure vs openpyxl
- [ ] **4.7** Add patcher benchmarks to ExcelBench perf dashboard

### Phase 5: Polish + documentation [~0.5 session]

- [ ] **5.1** Update CLAUDE.md architecture section with patcher
- [ ] **5.2** Update architecture.md with XlsxPatcher in dependency diagram
- [ ] **5.3** Add DEC-014 to decisions.md
- [ ] **5.4** Update blog post with modify mode benchmarks
- [ ] **5.5** Update pycalumya README/docstrings with modify mode examples

## Risks and mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| Rich text shared strings have nested `<r><rPr>` elements | Incorrectly parsed/corrupted | Parse `<r>` runs; for patching, use inline strings (`t="str"`) to avoid SST complexity |
| Worksheet XML has namespaces/prefixes that vary | Patcher breaks on some files | Use namespace-aware parsing; test against multiple Excel versions |
| Styles.xml has many interdependent sections | Format append creates invalid references | Always create component entries (font, fill, border) before referencing in `<xf>` |
| Concurrent file access during save | Data loss | Atomic write (tmp file + rename) already handled by existing pattern |
| Formula cells: cached `<v>` becomes stale | Incorrect values shown until recalc | Clear `<v>` when patching formula cells; Excel recalculates on open |
| Very large sharedStrings.xml (100K+ entries) | Slow string lookup | Use HashMap for dedup; consider inline strings for small patches |

## Open questions

1. ~~**Inline vs shared strings**~~: **RESOLVED** — Using inline strings (`t="str"`) always. Avoids
   touching sharedStrings.xml entirely. Simpler, faster, negligible file size impact for typical
   modify operations. SST parser still available for reading existing shared string references.

2. ~~**Feature flag**~~: **RESOLVED** — New `wolfxl` Cargo feature (`dep:zip, dep:quick-xml`).
   Independent of `rust_xlsxwriter` and `calamine` features.

3. **Row/column dimensions**: Should the patcher update `<dimension ref="A1:Z100">` in the worksheet
   root? This is optional per spec but some readers use it for allocation hints.

4. **Merged cell handling**: If a user writes to a cell that's part of a merge range, should we
   warn/error or silently proceed?
